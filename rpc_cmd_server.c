/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc_cmd.h"
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>

char * readBuff(FILE* stream)
{
    char buff[10];
    size_t cur_len = 0;
    size_t cur_max = 0;
    char *inputStd = NULL;

    while (fgets(buff, sizeof(buff), stream))
    {
        size_t buf_len = strlen(buff);
        if (cur_len + buf_len + 1 > cur_max)
        {
            size_t new_len = cur_max * 2 + 1;
            if (buf_len + 1 > new_len)
                new_len = buf_len + 1;
            char * extra = realloc(inputStd, new_len);
            if (extra == 0)
                break;
            inputStd = extra;
            cur_max = new_len;
        }
        strcpy(inputStd + cur_len, buff);
        cur_len += buf_len;
    }
    
    return inputStd;
}


cmdCallback * rcmd_1_svc(cmdParams *argp, struct svc_req *rqstp)
{
    int wholeLen = strlen(argp->command);   // Length of whole: command + arguments 
    for(int i = 0; i < argp->arguments.arguments_len; i++)
    {
        wholeLen = wholeLen + strlen(argp->arguments.arguments_val[i]) + 1;
    }
    
    // Combine command and arguments into one string
    char* cmd_ = malloc(wholeLen + 1);
    strcpy(cmd_, argp->command);
    strcat(cmd_, " ");
    for(size_t i = 0; i < argp->arguments.arguments_len; i++)
    {
        strcat(cmd_, argp->arguments.arguments_val[i]);
        strcat(cmd_, " ");
    }
    
    printf("%s\n", cmd_);
 
    // fd[0]: read end | fd[1]: write end
    int stdInput[2];    // stdin    descriptors
    int stdOutput[2];   // stdout   descriptors
    int stdError[2];    // stderr   descriptors

    pipe(stdInput);
    pipe(stdOutput);
    pipe(stdError);

    static cmdCallback result;  // command result to be pass to client

    int cpid;
    if((cpid=fork())==0)
    {     
        // duplikacja deskryptorów plików
        dup2(stdInput[0], STDIN_FILENO);
        dup2(stdOutput[1], STDOUT_FILENO);
        dup2(stdError[1], STDERR_FILENO);

        close(stdInput[0]);
		close(stdOutput[1]);
		close(stdError[1]);
		close(stdInput[1]);
		close(stdOutput[0]);
		close(stdError[0]);

        result.stat = WEXITSTATUS(system(cmd_));    // wywołanie komendy
        exit(result.stat);

    }
    else
    {
        close(stdInput[0]);
		close(stdOutput[1]);
		close(stdError[1]);
        // wpisanie na wyjście stdin strumienia z potoku
		write(stdInput[1], argp->pipeData, strlen(argp->pipeData)+1);
		close(stdInput[1]);

        int status;
		waitpid(cpid, &status, 0);
		result.stat = WEXITSTATUS(status);

        // ustawienie kanałów na nieblokujące
		fcntl(stdOutput[0], F_SETFL, O_NONBLOCK);
		fcntl(stdError[0], F_SETFL, O_NONBLOCK);
        
        FILE* stdOutputFile = fdopen(stdOutput[0], "r");
        result.stdout = readBuff(stdOutputFile);    // odczytanie strumienia
        fclose(stdOutputFile);
        if (!result.stdout) {   // problem przy pustym wskaźniku
            result.stdout = (char*)malloc(sizeof(char)* 1);
        }
        
        FILE* stdErrorFile = fdopen(stdError[0], "r");
        result.stderr = readBuff(stdErrorFile);     // odczytanie strumienia
        fclose(stdErrorFile);
        if (!result.stderr) {   // problem przy pustym wskaźniku
            result.stderr = (char*)malloc(sizeof(char)* 1);
        }

        return &result;
    }
}
